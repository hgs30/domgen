/* DO NOT EDIT: File is auto-generated */
package <%= to_package(repository.gwt.qualified_abstract_client_test_name) %>;

@java.lang.SuppressWarnings( { "UnusedDeclaration", "StaticImportCanBeUsed" } )
<% if repository.arez? -%>
@arez.testng.ActionWrapper( enable = true )
<% end -%>
public abstract class <%= repository.gwt.abstract_client_test_name %><T extends <%= repository.gwt.qualified_abstract_test_sting_injector_name %>>
<% if repository.arez? -%>
  implements arez.testng.ArezTestSupport
<% end -%>
{
  @javax.annotation.Nonnull
  private final java.util.List<java.lang.Runnable> _asyncActions = new java.util.ArrayList<>();
<% if repository.imit? -%>
  @javax.annotation.Nonnull
  private final TestTransport _replicantTransport = new TestTransport();
<% end -%>
<% repository.data_modules.select{|data_module|data_module.arez? && data_module.arez.factory_required?}.each do |data_module| -%>
  @SuppressWarnings( "NotNullFieldNotInitialized" )
  @javax.annotation.Nonnull
  protected <%= data_module.arez.qualified_test_factory_name %> <%= data_module.arez.short_test_code %>;
<% end -%>
  private T _injector;
<% if repository.arez? -%>
  @javax.annotation.Nonnull
  private final java.util.List<java.lang.String> _observerErrors = new java.util.ArrayList<>();
  private boolean _captureObserverErrors;
  @javax.annotation.Nullable
  private java.lang.String _currentMethod;
<% end -%>
<% if repository.imit? -%>
  @javax.annotation.Nullable
  private arez.Disposable _connector;
<% end -%>

  @javax.annotation.Nonnull
  protected abstract T createInjector();

  @javax.annotation.Nonnull
  protected T getInjector()
  {
    return _injector;
  }
<% if repository.arez? -%>

  protected final void captureObserverErrors()
  {
    _captureObserverErrors = true;
  }

  protected final void noCaptureObserverErrors()
  {
    _captureObserverErrors = false;
  }

  @org.testng.annotations.BeforeMethod
  public void handleTestMethodName( @javax.annotation.Nonnull final java.lang.reflect.Method method )
  {
    _currentMethod = method.getName();
    _captureObserverErrors = false;
    _observerErrors.clear();
    arez.Arez.context().addObserverErrorHandler( this::onObserverError );
  }

  private void onObserverError( @javax.annotation.Nonnull final arez.Observer observer, @javax.annotation.Nonnull final arez.ObserverError error, @javax.annotation.Nullable final java.lang.Throwable throwable )
  {
    final var message = "Observer: " + observer.getName() + " Error: " + error + " " + throwable;
    _observerErrors.add( message );
    if ( !_captureObserverErrors )
    {
      java.lang.System.out.println( message );
      if ( null != throwable )
      {
        throwable.printStackTrace( java.lang.System.out );
      }
    }
  }

  @org.testng.annotations.AfterMethod
  protected void afterTest()
  {
    arez.ArezTestUtil.resetConfig( true );
    if ( !_captureObserverErrors && !_observerErrors.isEmpty() )
    {
      org.testng.Assert.fail( "Unexpected Observer Errors: " + java.lang.String.join( "\n", _observerErrors ) );
    }
  }
<% end -%>

  @org.testng.annotations.BeforeMethod
<% if repository.arez? -%>
  @java.lang.Override
<% end -%>
  public void preTest()
    throws Exception
  {
    <%= repository.gwt.qualified_value_util_name %>.reset();
    <%= repository.gwt.qualified_value_util_name %>.setNow( new java.util.Date() );
<% if repository.arez? -%>
    arez.testng.ArezTestSupport.super.preTest();
<% if repository.imit? -%>
    replicant.ReplicantTestUtil.resetConfig( false );
    _replicantTransport.reset();
<% end -%>
<% end -%>
    _injector = createInjector();
<% repository.data_modules.select{|data_module|data_module.arez? && data_module.arez.factory_required?}.each do |data_module| -%>
    <%= data_module.arez.short_test_code %> = _injector.<%= Reality::Naming.camelize(data_module.name) %>Factory().get();
<% end -%>
<% if repository.arez? -%>
    arez.Arez.context().registerLocator( _injector.getLocator() );
<% end -%>
<% if repository.imit? -%>
    replicant.Replicant.context().registerConnector( getInjector().getSystemSchema(), _replicantTransport );
    pumpAllAsyncActions();
<% end -%>
  }
<% if repository.arez? -%>

  @org.testng.annotations.AfterMethod
<% if repository.arez? -%>
  @java.lang.Override
<% end -%>
  public void postTest()
  {
<% if repository.arez? -%>
<% if repository.imit? -%>
    arez.Disposable.dispose( _connector );
    _connector = null;
    replicant.ReplicantTestUtil.resetConfig( false );
<% end -%>
    arez.testng.ArezTestSupport.super.postTest();
<% end -%>
  }
<% end -%>
<% repository.gwt.test_class_contents.each do |content| -%>
<%= content -%>
<% end -%>

  protected final void assertAsyncActionCount( final int count )
  {
    org.testng.Assert.assertEquals( _asyncActions.size(), count );
  }

  protected final void pumpSingleAsyncAction()
  {
    org.testng.Assert.assertTrue( _asyncActions.size() > 1 );
    _asyncActions.remove( 0 ).run();
  }

  protected final void pumpAsyncActions( final int count )
  {
    assertAsyncActionCount( count );
    pumpAllAsyncActions();
  }

  protected final void pumpAllAsyncActions()
  {
    while( !_asyncActions.isEmpty() )
    {
      _asyncActions.remove( 0 ).run();
    }
  }

  protected final void queueAsyncActions( @javax.annotation.Nonnull final java.lang.Runnable action )
  {
    _asyncActions.add( action );
  }

  protected final int randomInt()
  {
    return <%= repository.gwt.qualified_value_util_name %>.randomInt();
  }

  protected final boolean randomBoolean()
  {
    return <%= repository.gwt.qualified_value_util_name %>.randomBoolean();
  }

  protected final int nextId()
  {
    return <%= repository.gwt.qualified_value_util_name %>.nextId();
  }

  @javax.annotation.Nonnull
  protected final java.util.Date now()
  {
    return <%= repository.gwt.qualified_value_util_name %>.now();
  }

  @javax.annotation.Nonnull
  protected final String randomString()
  {
    return <%= repository.gwt.qualified_value_util_name %>.randomString();
  }

  @javax.annotation.Nonnull
  protected final String randomString( final int stringLength )
  {
    return <%= repository.gwt.qualified_value_util_name %>.randomString( stringLength );
  }
<% if repository.imit? -%>

  @javax.annotation.Nonnull
  protected final org.mockito.ArgumentCaptor<<%= repository.gwt.qualified_async_error_callback_name %>> onFailureCaptor()
  {
    return org.mockito.ArgumentCaptor.forClass( <%= repository.gwt.qualified_async_error_callback_name %>.class );
  }

  @java.lang.SuppressWarnings( "unchecked" )
  @javax.annotation.Nonnull
  protected final <M> org.mockito.ArgumentCaptor<<%= repository.gwt.qualified_async_callback_name %><M>> onSuccessCaptor( @java.lang.SuppressWarnings( "unused" ) @javax.annotation.Nonnull final java.lang.Class<M> type )
  {
    return org.mockito.ArgumentCaptor.forClass( <%= repository.gwt.qualified_async_callback_name %>.class );
  }

  @javax.annotation.Nonnull
  protected final TestTransport replicantTransport()
  {
    return _replicantTransport;
  }

  @java.lang.SuppressWarnings( { "NonJREEmulationClassesInClientCode", "StaticImportCanBeUsed" } )
  public final class TestTransport
    extends replicant.AbstractTransport
  {
    @javax.annotation.Nonnull
    private final java.util.List<java.lang.Object> _remoteMessages = new java.util.ArrayList<>();

    public void reset()
    {
      unbind();
      resetRemoteMessages();
    }

    public void resetRemoteMessages()
    {
      _remoteMessages.clear();
    }

    @java.lang.Override
    protected void doConnect()
    {
      queueAsyncActions( () -> onMessageReceived( replicant.messages.SessionCreatedMessage.create( randomString() ) ) );
    }

    @java.lang.Override
    protected void sendRemoteMessage( @javax.annotation.Nonnull final Object message )
    {
      _remoteMessages.add( message );
    }

    @java.lang.Override
    protected void doDisconnect()
    {
      queueAsyncActions( this::onDisconnect );
    }

    @javax.annotation.Nullable
    public replicant.TransportContext transportContext()
    {
      return getTransportContext();
    }

    public void onExecResponseMessage( final int requestId, @javax.annotation.Nonnull final Object response )
    {
      onReplicantMessage( replicant.messages.UpdateMessage.create( requestId, null, null, null, null, response ) );
    }

    public void onReplicantMessage( @javax.annotation.Nonnull final replicant.messages.ServerToClientMessage message )
    {
      final replicant.TransportContext transportContext = replicantTransport().transportContext();
      org.testng.Assert.assertNotNull( transportContext );
      transportContext.onMessageReceived( message );
    }

    @javax.annotation.Nonnull
    public replicant.messages.ExecMessage expecExecMessage( final int index, @javax.annotation.Nonnull final String command, final int requestId )
    {
      final replicant.messages.ExecMessage execMessage = replicantTransport().expectRemoteMessage( index, replicant.messages.ExecMessage.class );
      org.testng.Assert.assertEquals( execMessage.getCommand(), command, "Expected request command " + command + " but was " + execMessage.getCommand() + " at index " + index );
      org.testng.Assert.assertEquals( execMessage.getRequestId(), requestId, "Expected request id " + requestId + " but was " + execMessage.getRequestId() + " at index " + index );
      return execMessage;
    }

    @java.lang.SuppressWarnings( "NonJREEmulationClassesInClientCode" )
    public <M> M expectRemoteMessage( final int index, @javax.annotation.Nonnull final java.lang.Class<M> type )
    {
      org.testng.Assert.assertTrue( _remoteMessages.size() > index, "No message at index " + index + ". Max messages " + _remoteMessages.size() + " Messages=" + _remoteMessages );
      final java.lang.Object message = _remoteMessages.get( index );
      org.testng.Assert.assertTrue( type.isInstance( message ), "Message at index " + index + " is not of type " + type );
      return type.cast( message );
    }

    public void assertRemoteMessageCount( final int count )
    {
      org.testng.Assert.assertEquals( _remoteMessages.size(), count );
    }
  }
<% end -%>
}
